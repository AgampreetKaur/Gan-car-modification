# -*- coding: utf-8 -*-
"""gancarmodification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ty-VIXLYVkRkoXR4CUUYVxFWl0Rn_rS
"""

from google.colab import files
uploaded = files.upload()  # Upload the .pth file here

import os
os.listdir()

!pip install fastapi uvicorn pyngrok nest_asyncio

# Import necessary libraries
from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import JSONResponse, FileResponse
from pydantic import BaseModel
from typing import List
import uvicorn
import os
from pathlib import Path
import torch
from torchvision.transforms import transforms
from PIL import Image

# Load your CycleGAN model
class CycleGANModel:
    def __init__(self, model_path):
        self.model_path = model_path
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model = self.initialize_model()  # Initialize the model architecture
        self.load_model()

    def initialize_model(self):
        # Define your CycleGAN generator architecture here
        # For example, if you're using a U-Net generator:
        from torchvision.models import resnet18  # Example; replace with your model architecture
        model = resnet18(pretrained=False)  # Replace with your actual generator architecture
        return model.to(self.device)

    def load_model(self):
        # Load the state dictionary into the model
        state_dict = torch.load(self.model_path, map_location=self.device)
        self.model.load_state_dict(state_dict)
        self.model.eval()

    def transform(self, input_image: Image.Image):
        # Preprocess the image
        transform_pipeline = transforms.Compose([
            transforms.Resize((256, 256)),
            transforms.ToTensor(),
            transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),
        ])
        input_tensor = transform_pipeline(input_image).unsqueeze(0).to(self.device)

        # Perform the transformation
        with torch.no_grad():
            output_tensor = self.model(input_tensor)

        # Postprocess the output image
        output_tensor = output_tensor.squeeze(0).cpu().detach()
        output_image = transforms.ToPILImage()(output_tensor).convert("RGB")
        return output_image


# Initialize the FastAPI app
app = FastAPI()

# Load the model
model_path = "/content/cycleGAN_generator.pth"  # Update with the correct path to your model
cyclegan = CycleGANModel(model_path)

# Define the list of car companies
CAR_COMPANIES = [
    "Audi", "Hyundai Creta", "Mahindra Scorpio", "Rolls Royce", "Swift", "Tata Safari", "Toyota Innova"
]

# Define API endpoints
@app.get("/car-companies")
async def get_car_companies():
    """Return the list of available car companies."""
    return {"car_companies": CAR_COMPANIES}

@app.post("/transform")
async def transform_image(
    source_company: str = Form(...),
    target_company: str = Form(...),
    image: UploadFile = File(...),
):
    """Transform an input image using CycleGAN."""
    if source_company not in CAR_COMPANIES or target_company not in CAR_COMPANIES:
        return JSONResponse(content={"error": "Invalid car company selection."}, status_code=400)

    try:
        # Load the uploaded image
        input_image = Image.open(image.file).convert("RGB")

        # Transform the image
        output_image = cyclegan.transform(input_image)

        # Save the output image
        output_path = Path("output")
        output_path.mkdir(exist_ok=True)
        output_file = output_path / f"transformed_{source_company}_to_{target_company}.jpg"
        output_image.save(output_file)

        return FileResponse(output_file, media_type="image/jpeg")

    except Exception as e:
        return JSONResponse(content={"error": str(e)}, status_code=500)

# Frontend HTML
FRONTEND_HTML = """
<!DOCTYPE html>
<html>
<head>
    <title>CycleGAN Car Transformation</title>
</head>
<body>
    <h1>CycleGAN Car Transformation</h1>
    <form id="upload-form" enctype="multipart/form-data">
        <label for="source_company">Source Car Company:</label>
        <select id="source_company" name="source_company">
        </select><br>

        <label for="target_company">Target Car Company:</label>
        <select id="target_company" name="target_company">
        </select><br>

        <label for="image">Upload Image:</label>
        <input type="file" id="image" name="image" accept="image/*"><br>

        <button type="submit">Transform</button>
    </form>

    <script>
        // Fetch car companies and populate dropdowns
        fetch('/car-companies')
            .then(response => response.json())
            .then(data => {
                const sourceSelect = document.getElementById('source_company');
                const targetSelect = document.getElementById('target_company');
                data.car_companies.forEach(company => {
                    const option1 = document.createElement('option');
                    option1.value = company;
                    option1.textContent = company;
                    sourceSelect.appendChild(option1);

                    const option2 = document.createElement('option');
                    option2.value = company;
                    option2.textContent = company;
                    targetSelect.appendChild(option2);
                });
            });

        // Handle form submission
        const form = document.getElementById('upload-form');
        form.addEventListener('submit', async (event) => {
            event.preventDefault();

            const formData = new FormData(form);
            const response = await fetch('/transform', {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const img = document.createElement('img');
                img.src = url;
                document.body.appendChild(img);
            } else {
                const error = await response.json();
                alert(error.error);
            }
        });
    </script>
</body>
</html>
"""

@app.get("/")
async def frontend():
    """Serve the frontend HTML."""
    return HTMLResponse(content=FRONTEND_HTML, status_code=200)

# Run the FastAPI app
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

